package com.carrotgarden.maven.scalor.scalajs

import org.apache.maven.plugins.annotations._
import org.scalajs.cli.Scalajsld

import scala.collection.mutable.ArrayBuffer

import java.io.File

import com.carrotgarden.maven.scalor.base
import com.carrotgarden.maven.scalor.eclipse

import com.carrotgarden.maven.tools.Description

/**
 * Scala.js linker interface.
 *
 * https://github.com/scala-js/scala-js-cli
 */
trait Linker {
  self : Build with eclipse.Build with base.Logging with base.Params with base.BuildAnyDependency =>

  import Linker._
  import com.carrotgarden.maven.scalor.util.Folder._

  @Description( """
  Regualr expression used to split linker options.
  """ )
  @Parameter(
    property     = "scalor.linkerOptionSeparator", //
    defaultValue = """\s+"""
  )
  var linkerOptionSeparator : String = _

  @Description( """
  Build options for Scala.js CLI in Eclipse.
  Uses [linkerOptionSeparator]
  """ )
  @Parameter(
    property     = "scalor.linkerInteractiveOptions", //
    defaultValue = "--fastOpt --sourceMap --debug --prettyPrint"
  )
  var linkerInteractiveOptions : String = _

  @Description( """
  Build options for Scala.js CLI in Jenkins.
  Uses [linkerOptionSeparator]
  """ )
  @Parameter(
    property     = "scalor.linkerIntegrationOptions", //
    defaultValue = "--fullOpt --sourceMap"
  )
  var linkerIntegrationOptions : String = _

  @Description( """
  Report linker arguments during mojo execution.
  """ )
  @Parameter(
    property     = "scalor.linkerShowArgs", //
    defaultValue = "true"
  )
  var linkerLogArgs : Boolean = _

  /**
   * Report linker arguments during mojo execution.
   */
  def lnkerReportArgs( args : Array[ String ] ) = if ( linkerLogArgs ) {
    say.info( "Scala.js linker args:" )
    args.foreach( item => say.info( "   " + item ) )
  }

  /**
   * Scala.js linker user options configuration.
   */
  def linkerUserOptions : Array[ String ] = {
    val options = if ( m2e.isPresent ) linkerInteractiveOptions else linkerIntegrationOptions
    options.split( linkerOptionSeparator )
  }

  /**
   * Scala.js linker option to generate runtime.js JavaScript output file.
   */
  def linkerRuntimeOutput : Array[ String ] = {
    val runtimeFile = new File( buildTargetFolder, linkerRuntimeJs )
    ensureParent( runtimeFile )
    Array[ String ]( "--output", runtimeFile.getCanonicalPath )
  }

  /**
   * Classes generated by current project and included in linker class path.
   */
  def linkerBuildClassPath : Array[ String ] = {
    convertFileString( buildDependencyFolders )
  }

  /**
   * Linker class path from project dependency artifacts in given scope.
   */
  def linkerDependencyFilePath : Array[ File ] = {
    projectClassPath( buildDependencyScopes )
  }

  /**
   * Linker class path from project dependency artifacts in given scope.
   */
  def linkerDependencyClassPath : Array[ String ] = {
    convertFileString( linkerDependencyFilePath )
  }

  /**
   * Produce runtime.js JavaScript for given scope.
   */
  def invokeLinker() = {
    val args = cleanup {
      linkerRuntimeOutput ++
        linkerUserOptions ++
        linkerBuildClassPath ++
        linkerDependencyClassPath
    }
    lnkerReportArgs( args )
    say.info( "Invoking Scala.js linker." )
    Scalajsld.main( args )
  }

}

object Linker {

  def cleanup( array : Array[ String ] ) : Array[ String ] = {
    array.filterNot( entry => entry == null || entry.isEmpty )
  }

}
